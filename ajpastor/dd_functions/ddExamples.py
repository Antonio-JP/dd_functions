
# This file was *autogenerated* from the file ./ddExamples.sage
from sage.all_cmdline import *   # import sage library


from sage.rings.polynomial.polynomial_ring import is_PolynomialRing;
from sage.rings.polynomial.multi_polynomial_ring import is_MPolynomialRing;

_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_6 = Integer(6)
from ajpastor.dd_functions.ddFunction import *;

from ajpastor.misc.dinamic_string import *;
#from ajpastor.dd_functions.ddParametrizedFunction import *;

## Global variables (PUBLIC)
DFinite_examples = {};
DDFinite_examples = {};

## Global variables (PRIVATE)
__example_names = {};

##################################################################################
##################################################################################
###
### Predefined examples
###
##################################################################################
##################################################################################
def DD_EXAMPLES_LOAD():
    global DFinite_examples; global DDFinite_examples;
    global __example_names;

    s = DFinite.element([_sage_const_1 ,_sage_const_0 ,_sage_const_1 ],[_sage_const_0 ,_sage_const_1 ], name=DinamicString("sin(_1)", "x"));
    c = DFinite.element([_sage_const_1 ,_sage_const_0 ,_sage_const_1 ],[_sage_const_1 ,_sage_const_0 ], name=DinamicString("cos(_1)", "x"));
    sh = DFinite.element([-_sage_const_1 ,_sage_const_0 ,_sage_const_1 ],[_sage_const_0 ,_sage_const_1 ], name=DinamicString("sinh(_1)", "x"));
    ch = DFinite.element([-_sage_const_1 ,_sage_const_0 ,_sage_const_1 ],[_sage_const_1 ,_sage_const_0 ], name=DinamicString("cosh(_1)", "x"));
    ln = DFinite.element([_sage_const_1 ,_sage_const_0 ,(x+_sage_const_1 )],[_sage_const_0 ,_sage_const_1 ], name=DinamicString("log(_1-1)", "x"));
    e = DFinite.element([-_sage_const_1 ,_sage_const_1 ],[_sage_const_1 ], name=DinamicString("exp(_1)", "x"));
    tan = DDFinite.element([-_sage_const_2 ,_sage_const_0 ,c**_sage_const_2 ],[_sage_const_0 ,_sage_const_1 ], name=DinamicString("tan(_1)", "x"));
    
    ## Defining D-Finite Examples
    DFinite_examples['e'] = e;
    DFinite_examples['ln'] = ln;
    DFinite_examples['sin'] = s;
    DFinite_examples['cos'] = c;
    DFinite_examples['sinh'] = sh;
    DFinite_examples['cosh'] = ch;
    P = DFiniteP.parameters()[_sage_const_0 ];
    DFinite_examples['bessel'] = DFiniteP.element([x**_sage_const_2 -P**_sage_const_2 ,x,x**_sage_const_2 ], name=DinamicString("bessel_J(_1,_2)", ["P","x"]));
    DFinite_examples['legendre'] = DFiniteP.element([P*(P+_sage_const_1 ), -_sage_const_2 *x,_sage_const_1 -x**_sage_const_2 ], name=DinamicString("legendre_P(_1,_2)", ["P","x"]));
    DFinite_examples['chebyshev1'] = DFiniteP.element([P**_sage_const_2 ,-x,(_sage_const_1 -x**_sage_const_2 )], name=DinamicString("chebyshev_T(_1,_2)", ["P","x"]));
    DFinite_examples['chebyshev2'] = DFiniteP.element([P*(P+_sage_const_2 ),-_sage_const_3 *x,_sage_const_1 -x**_sage_const_2 ], name=DinamicString("chebyshev_U(_1,_2)", ["P","x"]));
    
    ## Defining DD-Finite Examples
    DDFinite_examples['esin'] = DDFinite.element([_sage_const_1 ,-c], [_sage_const_1 ], name=DinamicString("exp(sin(_1))", "x"));
    DDFinite_examples['sine'] = DDFinite.element([e**_sage_const_2 ,-_sage_const_1 ,_sage_const_1 ],[_sage_const_0 ,_sage_const_1 ], name=DinamicString("sin(exp(_1))", "x"));
    DDFinite_examples['tan'] = [tan, DDFinite.element([_sage_const_0 ,-_sage_const_2 *s*c,c**_sage_const_2 ], [_sage_const_0 ,_sage_const_1 ], name=DinamicString("tan(_1)", "x"))];
    DDFinite_examples['bernoulli'] = DDFinite.element([x*e-e+_sage_const_1 ,x*(e-_sage_const_1 )],[_sage_const_1 ,-_sage_const_1 /_sage_const_2 ,_sage_const_1 /_sage_const_6 ,_sage_const_0 ]);
    
    ## Defining some names
    __example_names['exp'] = 'e';
    __example_names['log'] = 'ln';
    __example_names['sen'] = 'sin';
    __example_names['tg'] = 'tan';

def DFinite_example(input, n=_sage_const_0 ):
    if(DFinite_examples.has_key(input)):
        res = DFinite_examples[input];
    elif (__example_names.has_key(input) and DFinite_examples.has_key(__example_names[input])):
        res = DFinite_examples[__example_names[input]];
    else:
        raise ValueError('The DD-Function by name %s does not exist' %(input));
        
    if(type(res)==list):
        return res[n];
    else:
        return res;
    

def DDFinite_example(input, n = _sage_const_0 ):
    if(DDFinite_examples.has_key(input)):
        res = DDFinite_examples[input];
    elif (__example_names.has_key(input) and DDFinite_examples.has_key(__example_names[input])):
        res = DDFinite_examples[__example_names[input]];
    else:
        raise ValueError('The DD-Function by name %s does not exist' %(input));
        
    if(type(res)==list):
        return res[n];
    else:
        return res;
    
def DDFunction_example(input, n=_sage_const_0 ):
    try:
        return DFinite_example(input, n);
    except Exception:
        pass;
    try:
        return DDFinite_example(input, n);
    except Exception:
        pass;
        
    raise ValueError('No DD-Function by name %s exist' %(input));

##################################################################################
##################################################################################
###
### Trigonometric and Hyperbolic trigonometric Functions
###
##################################################################################
##################################################################################
@cached_function
def Sin(input, ddR = None):
    from ajpastor.dd_functions.ddFunction import DDFunction;
    if(isinstance(input, DDFunction)):
        return Sin(x)(input);
    f,dR = __decide_parent(input, ddR);
    
    evaluate = lambda p : dR.getSequenceElement(p,_sage_const_0 );
    if(evaluate(f) != _sage_const_0 ):
        raise ValueError("Impossible to compute sin(f) with f(0) != 0");
    
    df = dR.base_derivation(f);
    df2 = dR.base_derivation(df);
    
    newName = repr(f);
    if(hasattr(f, "_DDFunction__name") and (not(f._DDFunction__name is None))):
        newName = f._DDFunction__name;
    
    return dR.element([df**_sage_const_3 ,-df2,df],[_sage_const_0 ,evaluate(df),evaluate(df2)], name=DinamicString("sin(_1)", newName)); 

@cached_function    
def Cos(input, ddR = None):
    from ajpastor.dd_functions.ddFunction import DDFunction;
    if(isinstance(input, DDFunction)):
        return Cos(x)(input);
    f,dR = __decide_parent(input, ddR);
    
    evaluate = lambda p : dR.getSequenceElement(p,_sage_const_0 );
    if(evaluate(f) != _sage_const_0 ):
        raise ValueError("Impossible to compute cos(f) with f(0) != 0");
    
    df = dR.base_derivation(f);
    df2 = dR.base_derivation(df);
    
    newName = repr(f);
    if(hasattr(f, "_DDFunction__name") and (not(f._DDFunction__name is None))):
        newName = f._DDFunction__name;
    
    return dR.element([df**_sage_const_3 ,-df2,df],[_sage_const_1 ,_sage_const_0 ,-evaluate(df)**_sage_const_2 ], name=DinamicString("cos(_1)",newName)); 

@cached_function
def Tan(input, ddR = None):
    from ajpastor.dd_functions.ddFunction import DDFunction;
    if(isinstance(input, DDFunction)):
        return Tan(x)(input);
    if(input == x):
        return DDFinite_example('tan');
    g, dR = __decide_parent(input, ddR,_sage_const_2 );
    
    
    evaluate = lambda p : dR.getSequenceElement(p,_sage_const_0 );
    if(evaluate(g) != _sage_const_0 ):
        raise ValueError("Impossible to compute tan(f) with f(0) != 0");
    
    dg = dR.base_derivation(g); ddg = dR.base_derivation(dg);
    a = Cos(input)**_sage_const_2 ; b = dR.base().zero(); c = dR.base()(-_sage_const_2 );
    
    ### First we compute the new linear differential operator
    newOperator = dR.element([dg**_sage_const_3 *c,dg**_sage_const_2 *b-ddg*a,dg*a]).equation;
        
    ### Now, we compute the initial values required
    required = newOperator.get_jp_fo()+_sage_const_1 ;
        
    init_tan = Tan(x).getInitialValueList(required);
    init_input = [factorial(i)*dR.base().getSequenceElement(g,i) for i in range(required)];
        
    newInit = [init_tan[_sage_const_0 ]]+[sum([init_tan[j]*bell_polynomial(i,j)(*init_input[_sage_const_1 :i-j+_sage_const_2 ]) for j in range(_sage_const_1 ,i+_sage_const_1 )]) for i in range(_sage_const_1 ,required)]; ## See Faa di Bruno's formula
    
    result = dR.element(newOperator,newInit);
    
    newName = repr(input);
    if(hasattr(input, "_DDFunction__name") and (not(input._DDFunction__name is None))):
        newName = input._DDFunction__name;
    
    result._DDFunction__name = DinamicString("tan(_1)",newName);
    return result;

@cached_function    
def Sinh(input, ddR = None):
    from ajpastor.dd_functions.ddFunction import DDFunction;
    if(isinstance(input, DDFunction)):
        return Sinh(x)(input);
    f,dR = __decide_parent(input, ddR);
    
    evaluate = lambda p : dR.getSequenceElement(p,_sage_const_0 );
    if(evaluate(f) != _sage_const_0 ):
        raise ValueError("Impossible to compute sin(f) with f(0) != 0");
    
    df = dR.base_derivation(f);
    df2 = dR.base_derivation(df);
    
    newName = repr(f);
    if(hasattr(f, "_DDFunction__name") and (not(f._DDFunction__name is None))):
        newName = f._DDFunction__name;
    
    return dR.element([-df**_sage_const_3 ,-df2,df],[_sage_const_0 ,evaluate(df),evaluate(df2)], name=DinamicString("sinh(_1)",newName)); 

@cached_function    
def Cosh(input, ddR = None):
    from ajpastor.dd_functions.ddFunction import DDFunction;
    if(isinstance(input, DDFunction)):
        return Cosh(x)(input);
    f,dR = __decide_parent(input, ddR);
    
    evaluate = lambda p : dR.getSequenceElement(p,_sage_const_0 );
    if(evaluate(f) != _sage_const_0 ):
        raise ValueError("Impossible to compute cos(f) with f(0) != 0");
    
    df = dR.base_derivation(f);
    df2 = dR.base_derivation(df);
    
    newName = repr(f);
    if(hasattr(f, "_DDFunction__name") and (not(f._DDFunction__name is None))):
        newName = f._DDFunction__name;
    
    return dR.element([-df**_sage_const_3 ,-df2,df],[_sage_const_1 ,_sage_const_0 ,evaluate(df)**_sage_const_2 ], name=DinamicString("cosh(_1)", newName)); 

##################################################################################
##################################################################################
###
### Exponential and Logarithm Functions
###
##################################################################################
##################################################################################   
@cached_function  
def Log(input, ddR = None):
    from ajpastor.dd_functions.ddFunction import DDFunction;
    if(isinstance(input, DDFunction)):
        return Log(x+_sage_const_1 )(input);
    f,dR = __decide_parent(input, ddR);
    
    evaluate = lambda p : dR.getSequenceElement(p,_sage_const_0 );
    if(evaluate(f) != _sage_const_1 ):
        raise ValueError("Impossible to compute ln(f) with f(0) != 1");
    
    df = dR.base_derivation(f);
    df2 = dR.base_derivation(df);
    
    newName = repr(f);
    if(hasattr(f, "_DDFunction__name") and (not(f._DDFunction__name is None))):
        newName = f._DDFunction__name;
    
    return dR.element([_sage_const_0 ,df**_sage_const_2 -df2*f,df*f],[_sage_const_0 ,evaluate(df), evaluate(df2)-evaluate(df)**_sage_const_2 ], name=DinamicString("log(_1)",newName));
    
@cached_function 
def Log1(input, ddR = None):
    from ajpastor.dd_functions.ddFunction import DDFunction;
    if(isinstance(input, DDFunction)):
        return Log1(x)(input);
    f,dR = __decide_parent(input, ddR);
    
    evaluate = lambda p : dR.getSequenceElement(p,_sage_const_0 );
    if(evaluate(f) != _sage_const_0 ):
        raise ValueError("Impossible to compute cos(f) with f(0) != 0");
    
    df = dR.base_derivation(f);
    df2 = dR.base_derivation(df);
    
    f1 = f+_sage_const_1 ;
    
    newName = repr(f);
    if(hasattr(f, "_DDFunction__name") and (not(f._DDFunction__name is None))):
        newName = f._DDFunction__name;
    
    return dR.element([_sage_const_0 ,df**_sage_const_2 -df2*f1,df*f1],[_sage_const_0 ,evaluate(df), evaluate(df2)-evaluate(df)**_sage_const_2 ], name=DinamicString("log(_1+1)", newName)); 
    
@cached_function 
def Exp(input, ddR = None):
    from ajpastor.dd_functions.ddFunction import DDFunction;
    if(isinstance(input, DDFunction)):
        return Exp(x)(input);
    f,dR = __decide_parent(input, ddR);
    
    evaluate = lambda p : dR.getSequenceElement(p,_sage_const_0 );
    if(evaluate(f) != _sage_const_0 ):
        raise ValueError("Impossible to compute exp(f) with f(0) != 0");
    
    newName = repr(f);
    if(hasattr(f, "_DDFunction__name") and (not(f._DDFunction__name is None))):
        newName = f._DDFunction__name;
        
    return dR.element([-dR.base_derivation(f),_sage_const_1 ],[_sage_const_1 ], name=DinamicString("exp(_1)", newName));

##################################################################################
##################################################################################
###
### Special Functions
###
##################################################################################
##################################################################################    
### Bessel Functions
@cached_function 
def BesselD(input, kind = _sage_const_1 ):
    if(input is None):
        return DDFunction_example('bessel');
    elif(kind == _sage_const_1 ):
        try:
            alpha = QQ(input);
            if(alpha < _sage_const_0 ):
                raise ValueError("Impossible to manage Bessel functions of first kind with negative order");
                
            P = DFiniteP.parameters()[_sage_const_0 ];
            
            func = DDFunction_example('bessel')(**{str(P):alpha});
            if(alpha in ZZ):
                return func.change_init_values([_sage_const_0  for i in range(alpha)] + [_sage_const_1 /_sage_const_2 **alpha, _sage_const_0 , -((alpha+_sage_const_2 )/(_sage_const_2 **(alpha+_sage_const_2 )))], name = "bessel_J(%d,x)" %input);
            else:
                return func.change_init_values([_sage_const_0 ], name = DinamicString("bessel_J(_1,_2)", [str(input), "x"]));
        except TypeError:
            raise TypeError("Impossible to manage Bessel functions of first kind with irrational order");
    else:
        raise ValueError("Impossible to manage Bessel functions of %dth kind" %(kind));

### Legendre Polynomials     
__legendre_initials = [[_sage_const_1 ,_sage_const_0 ],[_sage_const_0 ,_sage_const_1 ]];   
@cached_function 
def LegendreD(input):
    global __legendre_initials;
    if(input is None):
        return DDFunction_example('legendre');

    try:
        n = ZZ(input);
        if(n < _sage_const_0 ):
            raise ValueError("Impossible to create a Legendre polynomial of negative index");
            
        P = DFiniteP.parameters()[_sage_const_0 ];  
        func = DDFunction_example('legendre')(**{str(P):n});
        for i in range(len(__legendre_initials), n+_sage_const_1 ):
            prev = __legendre_initials[-_sage_const_1 ];
            prev2 = __legendre_initials[-_sage_const_2 ];
            __legendre_initials += [[-(i-_sage_const_1 )*prev2[_sage_const_0 ]/i,((_sage_const_2 *i-_sage_const_1 )*prev[_sage_const_0 ] - (i-_sage_const_1 )*prev2[_sage_const_1 ])/i]];
        return func.change_init_values(__legendre_initials[n], name=DinamicString("legendre_P(_1,_2)", [str(input), "x"]));
    except TypeError as e:
        #raise TypeError("Impossible to create a Legendre polynomial of rational index");
        raise e;

### Chebyshev Polynomials        
__chebyshev_initials = [[],[[_sage_const_1 ,_sage_const_0 ],[_sage_const_0 ,_sage_const_1 ]],[[_sage_const_1 ,_sage_const_0 ],[_sage_const_0 ,_sage_const_2 ]]];
@cached_function    
def ChebyshevD(input, kind = _sage_const_1 ):
    global __chebyshev_initials;
    if(input is None):
        return DDFunction_example('chebyshev%d' %kind);

    try:
        n = ZZ(input);
        if(n < _sage_const_0 ):
            raise ValueError("Impossible to create a Legendre polynomial of negative index");
            
        P = DFiniteP.parameters()[_sage_const_0 ];
        ## Building the differential equation
        name = None;
        if(kind == _sage_const_1 ):
            func = DDFunction_example('chebyshev1')(**{str(P):n});
            name = DinamicString("chebyshev_T(_1,_2)", [str(input), "x"]);
        elif(kind == _sage_const_2 ):
            func = DDFunction_example('chebyshev2')(**{str(P):n});
            name = DinamicString("chebyshev_U(_1,_2)", [str(input), "x"]);
        else:
            raise ValueError("Impossible to manage Chebyshev polynomial of %d-th kind" %(kind));
            
        ## Computing initial values
        for i in range(len(__chebyshev_initials[kind]), n+_sage_const_1 ):
            prev = __chebyshev_initials[kind][-_sage_const_1 ];
            prev2 = __chebyshev_initials[kind][-_sage_const_2 ];
            __chebyshev_initials[kind] += [[-prev2[_sage_const_0 ], _sage_const_2 *prev[_sage_const_0 ]-prev2[_sage_const_1 ]]];
        return func.change_init_values(__chebyshev_initials[kind][n],name);
    except TypeError as e:
        raise e;    

### Hypergeometric Functions
__CACHED_HYPERGEOMETRIC = {};

def HypergeometricFunction(a,b,c, init = _sage_const_1 ):
    return GenericHypergeometricFunction([a,b],[c],init);

def GenericHypergeometricFunction(num=[],den=[],init=_sage_const_1 ):
    if (not (isinstance(num,list) or isinstance(num,set) or isinstance(num,tuple))):
        num = [num];
    else:
        num = list(num);
    if (not (isinstance(den,list) or isinstance(den,set) or isinstance(den,tuple))):
        den = [den];
    else:
        den = list(den);
        
    ## Cleaning repeated values 
    i = _sage_const_0 ;
    while(i < len(num) and len(den) > _sage_const_0 ):
        if(num[i] in den):
            den.remove(num[i]);
            num.remove(num[i]);
        else:
            i += _sage_const_1 ;
    
    ## Sort list for cannonical input
    num.sort(); den.sort();
    
    ## Casting to tuples to have hash  
    num = tuple(num); den = tuple(den);
    
    ## Checking the function is cached
    global __CACHED_HYPERGEOMETRIC;
    if(not((num,den,init) in __CACHED_HYPERGEOMETRIC)):
        ## Building differential operator
        get_op = lambda p : DFinite.element(p).equation;
        op_num = x*prod(get_op([el,x]) for el in num);
        op_den = x*get_op([_sage_const_0 ,_sage_const_1 ])*prod(get_op([el-_sage_const_1 ,x]) for el in den);
        op = op_num - op_den;
        
        f = DFinite.element(op);
        
        initVals = [init];
        
        if(init == _sage_const_1 ):
            __CACHED_HYPERGEOMETRIC[(num,den,init)] = f.change_init_values([_sage_const_1 ],name=DinamicString("hypergeometric(_1,_2,_3)", [str(num),str(den),"x"]));
        else:
            __CACHED_HYPERGEOMETRIC[(num,den,init)] = f.change_init_values([init],name=DinamicString("%d*(hypergeometric(_1,_2,_3))", [str(num),str(den),"x"]));
        
    ## Return the cached element
    return __CACHED_HYPERGEOMETRIC[(num,den,init)];
    
### Mathieu's Functions
@cached_function
def MathieuD(a=None,q=None,init=()):
    params =[];
    if(a is None):
        params += ['a'];
    if(q is None):
        params += ['q'];
    
    destiny_ring = DDFinite; ra = a; rq = q;
    if(len(params) > _sage_const_0 ):
        destiny_ring = ParametrizedDDRing(DDFinite, params);
        if(len(params) == _sage_const_2 ):
            ra,rq = destiny_ring.parameters();
        elif('a' in params):
            ra = destiny_ring.parameters()[_sage_const_0 ]; rq = q;
        else:
            rq = destiny_ring.parameters()[_sage_const_0 ]; ra = a;
        
    return destiny_ring.element([ra-_sage_const_2 *rq*Cos(_sage_const_2 *x), _sage_const_0 , _sage_const_1 ], init, name=DinamicString("Mathieu(_1,_2;_3)(_4)", [repr(ra),repr(rq),str(list(init[:_sage_const_2 ])),"x"]));

@cached_function
def MathieuSin(a=None,q=None):
    return MathieuD(a,q,(_sage_const_0 ,_sage_const_1 ));
    
@cached_function
def MathieuCos(a=None,q=None):
    return MathieuD(a,q,(_sage_const_1 ,_sage_const_0 ));

### Airy's functions
@cached_function
def AiryD(init=()):
    name = None;
    if(len(init) >= 2): ## Complete Airy function, we can build the name
        ## Rejecting the zero case
        if(init[0] == init[1] and init[0] == 0):
            return DFinite.zero();
        
        ## Simplifying the name if there is zero coefficients
        if(init[0] != 0):
            name_a1 = "(3**(2/3)*gamma(2/3))*%s" %init[0];
            name_b1 = "(3**(1/3)*gamma(2/3))*%s" %init[0];
        else:
            name_a1 = "";
            name_b1 = "";
        if(init[1] != 0):
            name_a2 = "-(3**(1/3)*gamma(1/3))*%s" %init[1];
            name_b2 = "+(gamma(1/3))*%s" %init[1];
        else:
            name_a2 = "";
            name_b2 = "";
            
        ## Building the final name
        name = DinamicString("((%s%s)/2)*airy_ai(_1) + ((%s%s)/(2*3**(1/6)))*airy_bi(_1)" %(name_a1, name_a2, name_b1, name_b2), ["x"]);
    return DFinite.element([-x,0,1], init, name=name);

### Struve's functions
@cached_function
def StruveD(mu,kind=1):
    raise NotImplementedError("Struve functions not yet implemented");
    if(kind != 1):
        raise TypeError("Only struve_H functions are implemented");
    elif((mu < 0) or (mu not in ZZ)):
        raise TypeError("Parameter must be greater or equal to -1 to have a power series (got %d)" %mu);
    
    name=DinamicString("(%s)*struve_H(%s,_1)" %((1/(struve_H(mu,x).derivative(mu+1)(x=0))),mu), ["x"]);
    init = [0 for i in range(mu+1)] + [1];
    return DFinite.element([x**2*(1-mu)-mu**2,x*(x**2-mu**2-mu),-(mu-2)*x**2,x**3], init, name=name);

### Parabolic Cylinder Functions
@cached_function
def ParabolicCylinderD(a=None,b=None,c=None, init=()):
    params =[];
    if(a is None):
        params += ['a'];
    if(b is None):
        params += ['b'];
    if(c is None):
        params += ['c'];
    
    destiny_ring = DFinite; ra = a; rb = b; rc = c;
    if(len(params) > _sage_const_0 ):
        destiny_ring = ParametrizedDDRing(DFinite, params);
        if(len(params) == 3 ):
            ra,rb,rc = destiny_ring.parameters();
        elif(len(params) == 2 and 'a' not in params):
            rb,rc = destiny_ring.parameters();
        elif(len(params) == 2 and 'b' not in params):
            ra,rc = destiny_ring.parameters();
        elif(len(params) == 2 and 'c' not in params):
            ra,rb = destiny_ring.parameters();
        elif('a' in params):
            ra = destiny_ring.parameters()[0];
        elif('b' in params):
            rb = destiny_ring.parameters()[0];
        elif('c' in params):
            rc = destiny_ring.parameters()[0];
    return destiny_ring.element([(rc+rb*x+ra*x**2),0,1], init, name=DinamicString("ParabolicCylinder(_1,_2,_3;_4)", [repr(ra), repr(rb), repr(rc), "x"]));
    
##################################################################################
##################################################################################
###
### Algebraic functions
###
##################################################################################
################################################################################## 
def DAlgebraic(polynomial, init=[], dR=None):
    '''
        Method that transform an algebraic function to a DD-Function.
                
        INPUT:
            - polynomial: the minimal polynomial of the function we want to transform.
            - init: the initial values that the function will have. Two options are 
            possible: a list is given, then we will use it directly to build the final 
            result, or a value is given an we will compute the others using the polynomial 
            equation.
            - dR: the ring where we want to include the result. If None, an automatic 
            destiny ring will be computed.
            
        OUTPUT:
            - A DDFunction in a particuar DDRing.
            
        WARNINGS:
            - There is no control about the irreducibility of the polynomial.
            
        ERRORS:
            - If the function can not be represented in dR a TypeError will be raised
            - If any error happens with the initial values, a ValueError will be raised
    '''
    ## Local imports
    from sage.rings.polynomial.polynomial_ring import is_PolynomialRing as isPolynomial;
    from sage.rings.polynomial.multi_polynomial_ring import is_MPolynomialRing as isMPolynomial;
    from sage.categories.pushout import FractionField;
    from ajpastor.misc.matrix import matrix_of_dMovement as move;
    
    ###############################################
    ## Dealing with the polynomial input
    ###############################################
    parent = polynomial.parent();
    if(not (isPolynomial(parent) or isMPolynomial(parent))):
        raise TypeError("The minimal polynomial is NOT a polynomial");
    
    base_ring = None;  
    F = None;  
    poly_ring = parent;
    if(isMPolynomial(parent)):
        base_ring = PolynomialRing(parent.base(),parent.gens()[:-_sage_const_1 ]);
        poly_ring = PolynomialRing(base_ring.fraction_field(), parent.gens()[-_sage_const_1 ]);
    else:
        if(isinstance(parent.base().construction()[_sage_const_0 ], FractionField)):
            base_ring = parent.base().base();
        else:
            base_ring = parent.base();
            if(not parent.base().is_field()):
                poly_ring = PolynomialRing(parent.base().fraction_field(), parent.gens()[-_sage_const_1 ]);
                
    F = poly_ring.base();
    y = poly_ring.gens()[-_sage_const_1 ];
    ## At this point we have the following
    ##   - F is a field
    ##   - y is a variable
    ##   - poly_ring == F[y]
    polynomial = poly_ring(polynomial); ## Now the structure is univariate
    if(polynomial.degree() == _sage_const_1 ):
        return -polynomial[_sage_const_0 ]/polynomial[_sage_const_1 ];
    elif(polynomial.degree() <= _sage_const_0 ):
        raise TypeError("Constant polynomial given for algebraic function: IMPOSSIBLE!!");
        
    #################################################
    ## Building and checking the destiny ring
    #################################################
    destiny_ring = None;
    if(dR is None):
        destiny_ring = DDRing(base_ring);
    else:
        destiny_ring = dR;
        coercion = destiny_ring._coerce_map_from_(base_ring);
        if((coercion is None) or (coercion is False)):
            raise TypeError("Incompatible polynomial with destiny ring:\n\t- Coefficients in: %s\n\t- Destiny Ring: %s" %(base_ring, destiny_ring));
            
    dest_var = repr(destiny_ring.variables()[_sage_const_0 ]);
    
    ##################################################
    ## Computing the differential equation
    ##################################################
    ## Computing the derivative
    dy = polynomial.derivative(y);
    
    ## Getting its gcd with the polynomial
    g,r,s = polynomial.xgcd(dy);
    if((g != _sage_const_1 ) or (not(g in poly_ring.base()))):
        raise ValueError("No irreducible polynomial given");
        
    ## Computing the coefficient-wise derivation of polynomial
    mon = poly_ring(_sage_const_1 );
    ky = poly_ring(_sage_const_0 );
    for i in range(polynomial.degree()+_sage_const_1 ):
        ky += (polynomial[i].derivative())*mon;
        mon *= y;
        
    ## Getting the polynomial expression of y', y'',..., y^{(deg(polynomial))}
    rows = [[_sage_const_0 ]*polynomial.degree()];
    mon = poly_ring(_sage_const_1 );
    for i in range(polynomial.degree()-_sage_const_1 ):
        rows += [((-(i+_sage_const_1 )*mon*s*ky)%polynomial).coefficients(False)];
        mon *= y;
        
    ## Building the derivation matrix of <1,y,y^2,...>
    M = Matrix(F, rows).transpose();
    ## Creating the vector representing y
    y_vector = vector(F, [_sage_const_0 ,_sage_const_1 ] + [_sage_const_0 ]*(polynomial.degree()-_sage_const_2 ));
    ## Building ans solving the system
    to_solve = move(M, y_vector, lambda p : p.derivative(), M.ncols()+_sage_const_1 );
    v = to_solve.right_kernel_matrix()[_sage_const_0 ];
    
    ## Cleaning denominators
    cleaning = lcm(el.denominator() for el in v);
    
    equation = destiny_ring.element([F.base()(el*cleaning) for el in v]).equation;
    
    ##################################################
    ## Getting the initial values
    ##################################################
    if(not (type(init) is list)):
        ## We try to compute the new initial values
        init = [init];
        go_on = True;
        for i in range(_sage_const_1 ,min(equation.get_jp_fo()+_sage_const_2 , to_solve.ncols())):
            try:
                init += [sum(to_solve[j,i](**{dest_var:_sage_const_0 })*init[_sage_const_0 ]**j for j in range(polynomial.degree()))];
            except ZeroDivisionError:
                go_on = False;
                break;
        
        if(go_on and (equation.get_jp_fo()+_sage_const_2  > to_solve.ncols())):
            extra = move(M, vector(F,[el[_sage_const_0 ] for el in to_solve[:,-_sage_const_1 ]]), equation.get_jp_fo()+_sage_const_2 -to_solve.ncols());
            init += [sum(extra[j,i](**{dest_var:_sage_const_0 })*init[_sage_const_0 ]**j for j in range(polynomial.degree())) for i in range(extra.ncols())];
    
    ##################################################
    ## Returning the DDFunction
    ##################################################
    return destiny_ring.element(equation, init);
    
##################################################################################
##################################################################################
###
### Particular differential Equations
###
##################################################################################
##################################################################################  
### Federschwinger // Swing with mass
## f'' + 2a f' + b^2f = ksin(cx)
@cached_function
def Federschwinger(a,b,c,k,init=(_sage_const_0 ,_sage_const_0 )):
    return DDFinite.element([b**_sage_const_2 ,_sage_const_2 *a,_sage_const_1 ], init, k*Sin(c*x));
    
##################################################################################
##################################################################################
###
### Private methods
###
##################################################################################
##################################################################################    
def __decide_parent(input, parent = None, depth = 1):
    if(parent is None):
        R = input.parent();
        if(isinstance(R, sage.symbolic.ring.SymbolicRing)):
            parameters = set([str(el) for el in input.variables()])-set(['x']);
            if(len(parameters) > 0 ):
                parent = ParametrizedDDRing(DDRing(DFinite, depth=depth), parameters);
            else:
                parent = DDRing(PolynomialRing(QQ,x), depth=depth);
        elif(is_MPolynomialRing(R) or is_PolynomialRing(R)):
            parameters = [str(gen) for gen in R.gens()[1:]];
            if(len(parameters) > 0):
                parent = ParametrizedDDRing(DDRing(PolynomialRing(QQ,R.gens()[0]), depth=depth), parameters);
            else:
                parent = DDRing(PolynomialRing(QQ,R.gens()[0]), depth = depth);
        else:
            try:
                parent = DDRing(R, depth = depth);
            except Exception:
                raise TypeError("The object provided is not in a valid Parent", e);
    
    return parent.base()(input), parent;
    
#### Usual running after defining everything
DD_EXAMPLES_LOAD();

