
# This file was *autogenerated* from the file ./bareiss.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0)
from .matrix import swap_rows;
from .matrix import swap_cols;

from .cached_property import derived_property;

from .verbose import *;

from sage.rings.polynomial.polynomial_ring import is_PolynomialRing as isUniPolynomial;
from sage.rings.polynomial.multi_polynomial_ring import is_MPolynomialRing as isMPolynomial;

class BareissAlgorithm(object):
    ### Initialization method
    def __init__(self, parent, M, method=None, relations = []):
        '''
            This class represent the application of the Bareiss Algorithm over a matrix with polynomial coefficients.
            This class receives several parameters:
                - `parent`: the polynomial ring where the operations will be done. A fraction field is allowed if the base domain is a polynomial ring.
                - `M`: the matrix we want to treat with the Algorithm
                - `method`: a Boolean function
                
            This algorithm also works in a quotient of the polynomial ring (K[X]/I) and the method provided must be a method to check if some polynomial is in the ideal I.
        '''
        ## Checking the parent parameter
        if(parent.is_field()):
            parent = parent.base();
        if(not (isUniPolynomial(parent) or isMPolynomial(parent))):
            raise TypeError("The parent for this algorithm must be a polynomial ring.\n\t Got: %s" %parent);
        self.__parent = parent;
            
        ## Checking the matrix input
        self.base_matrix = Matrix(self.parent(), M);
        
        self.change_of_columns = Permutation(range(_sage_const_1 ,self.base_matrix.ncols()));
        
        ## Storing the checking method
        self.__in_ideal = method;
        
        ## Cached elements
        self.__steps = None;
        self.__actions = None;
        self.__gb = ideal(self.parent(), relations).groebner_basis();
        self.__echelon = None;
        
        
    ### Getter methods
    def parent(self):
        '''
            Method to have the same interface that the majority of objects of SAGE. Returns the polynomial ring where the matrix have its coefficients.
        '''
        return self.__parent;
        
    #################################################
    ### Linear algebra methods
    #################################################
    #@wverbose
    def echelon_form(self):
        if(self.__echelon is None):
            self.__compute_echelon();
        return self.__echelon;
        
    @wverbose
    def __compute_echelon(self):
        sverbose("Computing the echelon form of a matrix of size %dx%d" %(self.base_matrix.nrows(), self.base_matrix.ncols()));
        
        self.__actions = [("base")];
        self.__steps = [self.base_matrix];
        
        ## If we have initial relations, we perform the first reduction
        if(self.__have_ideal(self.__gb)):
            sverbose("Initial reduction of the matrix"); ## Verbose
            self.__steps += [self.__simplify_matrix(self.__steps[-_sage_const_1 ])];
            self.__actions += [("f_reduce", self.__gb)];
        
        tr = self.__steps[-_sage_const_1 ].nrows(); tc = self.__steps[-_sage_const_1 ].ncols();
        cr = _sage_const_0 ; cc = _sage_const_0 ; i = -_sage_const_1 ;
        
        sverbose("Starting the iterations");
        sverbose.start_iteration(min(tr,tc)+_sage_const_1 , True, False);
        while(i < min(tr,tc)):
            i = i + _sage_const_1 ;
            
            sverbose.increase_depth();
            
            pivot = self.__choose_pivot(self.__steps[-_sage_const_1 ], i,i);
            
            cr,cc = pivot[_sage_const_0 ];
            new_rels = pivot[_sage_const_2 ];
            
            ## If there are new relations, we simplify the matrix
            if(len(new_rels) > _sage_const_0 ):
                sverbose("New relations found looking for a pivot");
                sverbose("\t%s" %new_rels);
                self.__gb = ideal(self.parent(), tuple(new_rels) + tuple(self.__gb)).groebner_basis();
                self.__steps += [self.__simplify_matrix(self.__steps[-_sage_const_1 ])];
                self.__actions += [("reduce", new_rels)];
                sverbose("New reductions applied");
                    
            ## If no pivot was found, we finish
            if(cr == -_sage_const_1  or cc == -_sage_const_1 ):
                sverbose("No pivot found.");
                sverbose.decrease_depth();
                sverbose.next_iteration();
                break;
                    
            ## If we have a new pivot, we moved everythin so it is in the proper position
            swap_actions = pivot[_sage_const_1 ];
            for action in swap_actions:
                if(action[_sage_const_0 ] == "sw_r"):
                    self.__steps += [swap_rows(self.__steps[-_sage_const_1 ], action[_sage_const_1 ],action[_sage_const_2 ])];
                elif(action[_sage_const_0 ] == "sw_c"):
                    self.__steps += [swap_cols(self.__steps[-_sage_const_1 ], action[_sage_const_1 ],action[_sage_const_2 ])];
                    self.change_of_columns = Permutation((action[_sage_const_1 ]+_sage_const_1 ,action[_sage_const_2 ]+_sage_const_1 ))*self.change_of_columns;
                    
                self.__actions += [action];
                
            ## One the pivot is in position, we proceed with the Bareiss elimination
            M = self.__steps[-_sage_const_1 ];
            
                
            ## We save the new matrix and go on
            self.__steps += [self.__bareiss(self.__steps[-_sage_const_1 ], i)];
            self.__actions += [("bareiss", i)];
            
            sverbose.decrease_depth();
            sverbose.next_iteration();
            
        sverbose("Performing gcd simplification");
        gcds = [gcd(row) for row in self.__steps[-_sage_const_1 ]];
        for i in range(len(gcds)):
            if(gcds[i] == _sage_const_0 ):
                gcds[i] = _sage_const_1 ;
        self.__steps += [Matrix(self.parent(), [[el/gcds[i] for el in self.__steps[-_sage_const_1 ][i]] for i in range(self.__steps[-_sage_const_1 ].nrows())])];
        self.__actions += [("gcd_simpl")];
            
        self.__echelon = self.__steps[-_sage_const_1 ];
        sverbose("Finished computation of echelon form");
                                
        return;
        
    @derived_property
    def rank(self):
        for i in range(self.base_matrix.nrows()):
            if(any((el != _sage_const_0 ) for el in self.echelon_form()[-(i+_sage_const_1 )])):
                return self.base_matrix.nrows()-i;
                
    def relations(self):
        self.echelon_form();
        return self.__gb;
                
    @cached_method
    def right_kernel_matrix(self):
        sol_dimension = self.base_matrix.ncols()-self.rank;        
        M = self.echelon_form();
        
        if(sol_dimension > _sage_const_0 ):
            ## Compute the product of the nice diagonal
            A = self.__get_lcm([M[i][i] for i in range(self.rank)]);
            to_mult = [-A/M[i][i] for i in range(self.rank)];
        
            ker_basis = [vector(self.parent(), [to_mult[j]*M[j][i+self.rank] for j in range(self.rank)] + [_sage_const_0  for j in range(i)] + [A] + [_sage_const_0  for j in range(i+_sage_const_1 , sol_dimension)]) for i in range(sol_dimension)];
            
            ch = self.change_of_columns;
            ## If there were a change of columns (i.e. ch is not the trivial permutation) 
            ## we swap the result
            if(Permutation(range(_sage_const_1 ,self.base_matrix.ncols())) != ch):
                ch = ch.inverse();
                rows = [[_sage_const_0  for i in range(M.ncols())] for j in range(len(ker_basis))];
                for j in range(M.ncols()):
                    new_col = ch(j+_sage_const_1 )-_sage_const_1 ;
                    for i in range(len(ker_basis)):
                        rows[i][new_col] = ker_basis[i][j];
                
                ker_basis = [vector(self.parent(), row) for row in rows];            
            
            return ker_basis;
        else:
            return [vector(self.parent(), [_sage_const_0  for i in range(M.ncols())])];
        
    #################################################
    ### Other cached methods
    #################################################
    @cached_method
    def is_in_ideal(self, p):
        p = self.parent()(p);
        
        try:
            return self.__in_ideal(p) is True;
        except Exception:
            return False;
          
    @cached_method
    def steps(self):
        '''
            This method returns a list of pairs with the matrices obtained during the proccess and the steps taken.
        '''
        self.echelon_form();
        
        return [(self.__steps[i],self.__actions[i]) for i in range(len(self.__steps))];
        
    #################################################
    ### Private methods for Bareiss Algorithm 
    #################################################
    @wverbose
    def __choose_pivot(self, M, ir, ic):
        '''
            This method computes the next pivot element for the algorithm and returns the information to prepare the matrix for the next step.
            The ir and ic are parameters to begin the search from the position (ir,ic)
        '''
        
        sverbose("Looking for a new pivot from position (%d,%d)" %(ir,ic));
        relations = set();
        actions = [];
        end = False;
        fc = -_sage_const_1 ; fr = -_sage_const_1 ;
        ## Checking rows
        for cc in range(ic, M.ncols()):
            ## Checking columns
            for cr in range(ir, M.nrows()):
                sverbose("Checking if position (%d,%d) is zero (%s)" %(cr,cc, M[cr][cc]));
                to_check = M[cr][cc];
                if(len(relations) > _sage_const_0 ):
                    sverbose("Reducing the selected element with the found relations");
                    to_check = M[cr][cc].reduce(relations);
                    sverbose("New element to check: %s" %(to_check));
                    
                if(not to_check == self.parent().zero()):
                    if(not self.is_in_ideal(to_check)):
                        sverbose("Non-zero element found. Pivot found");
                        end = True;
                        fr = cr;
                        break;
                    else:
                        sverbose("Non trivial zero found. New relation: %s" %(to_check));
                        relations.add(to_check);
            
            if(end):
                fc = cc;
                break;
        
        if(fc != -_sage_const_1  and fc != ic):
            actions += [("sw_c", ic, cc)];
            for i in range(_sage_const_1 ,(min(cc-ic, M.ncols()-cc))):
                actions += [("sw_c", ic+i, M.ncols()-i)];
        
        if(fr != -_sage_const_1  and fr != ir):
            actions += [("sw_r", ir, cr)];
            
        sverbose("Finished search of pivot: (%s,%s)" %(fr,fc));
                
        return ((fr,fc), tuple(actions), relations);
        
    def __bareiss(self, M, i):
        rows = [];
        for j in range(i):
            if(M[j][i] != _sage_const_0 ):
                rows += [[M[j][k]*M[i][i]-M[j][i]*M[i][k] for k in range(M.ncols())]];
            else:
                rows += [[M[j][k] for k in range(M.ncols())]];
        rows += [[M[i][k] for k in range(M.ncols())]];
        for j in range(i+_sage_const_1 , M.nrows()):
            if(M[j][i] != _sage_const_0 ):
                rows += [[M[j][k]*M[i][i]-M[j][i]*M[i][k] for k in range(M.ncols())]];
            else:
                rows += [[M[j][k] for k in range(M.ncols())]];
        
        try:
            gcds = [gcd(row) for row in rows];
            rows = [[el/gcd[i] for el in rows[i]] for i in range(len(rows))];
        except Exception:
            pass;
            
        return Matrix(self.parent(), rows);
        
    def __have_ideal(self, basis):
        if(len(basis) == _sage_const_1 ):
            return basis[_sage_const_0 ] != _sage_const_0 ;
        return len(basis) > _sage_const_0 ;
        
    def __simplify_matrix(self, M):
        rows = [[el for el in row] for row in M];
        if(self.__have_ideal(self.__gb)):
            rows = [[el.reduce(self.__gb) for el in row] for row in rows];
        
        return Matrix(self.parent(), rows);
        
    def __get_lcm(self, input):
        try:
            return lcm(input);
        except AttributeError:
            ## No lcm for this class, implementing a general lcm
            try:
                ## Relying on gcd
                p = self.__parent;
                res = p(_sage_const_1 );
                for el in input:
                    res = p((res*el)/gcd(res,el));
                return res;
            except AttributeError:
                ## Returning the product of everything
                return prod(input);
        
        

