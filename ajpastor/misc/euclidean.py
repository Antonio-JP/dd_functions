
# This file was *autogenerated* from the file ./euclidean.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_0 = Integer(0)

####################################################################################################
####################################################################################################
###
### Euclidean module
###
### ------------------------------------------------------------------------------------------------
###
### This file contains the code for some euclidean operations over for polynomials.
### 
### ------------------------------------------------------------------------------------------------
###
### Version: 0.0
### Date of begining: 29-03-2017
####################################################################################################
####################################################################################################

## Basic polynomial -- Private functions
def __coefficients(PolR, p, var):
    p = PolR(p);
    if(not var in PolR.gens()):
        raise ValueError("The variable given (%s) is not in the ring %s"%(var, PolR));
        
    var = PolR(var);
    
    try:
        return [p.coefficient({var:i}) for i in range(p.degree(var)+_sage_const_1 )];
    except TypeError:
        return p.coefficients(sparse = False);
        
def __lc(PolR, p, var):
    return __coefficients(PolR, p, var)[-_sage_const_1 ];
    
def __degree(PolR, p, var):
    p = PolR(p);
    if(not var in PolR.gens()):
        raise ValueError("The variable given (%s) is not in the ring %s"%(var, PolR));
        
    var = PolR(var);
    try:
        return p.degree(var);
    except TypeError:
        return p.degree();
        
## Polynomial Division
def PolyDivide(PolR, A,B):
    A = PolR(A); B = PolR(B);
    x = PolR.gens()[-_sage_const_1 ];
    
    Q = PolR.zero(); R = A;
    d = __degree(PolR, R, x) - __degree(PolR, B, x);
    while(R != PolR.zero() and d >= _sage_const_0 ):
        T = (__lc(PolR, R, x)/__lc(PolR, B, x))*x**d;
        Q += T;
        R -= B*T;
        d = __degree(PolR, R, x) - __degree(PolR, B, x);
        
    return (Q,R);
    
def PolyPseudoDivide(PolR, A, B):
    A = PolR(A); B = PolR(B);
    x = PolR.gens()[-_sage_const_1 ];
    
    b = __lc(PolR, B, x); N = __degree(PolR, A, x) - __degree(PolR, B, x)+_sage_const_1 ;
    Q = PolR.zero(); R = A;
    d = __degree(PolR, R, x) - __degree(PolR, B, x);
    while(R != PolR.zero() and d >= _sage_const_0 ):
        T = __lc(PolR, R, x)*x**d;
        N -= _sage_const_1 ;
        Q = b*Q + T;
        R = b*R - T*B;
        d = __degree(PolR, R, x) - __degree(PolR, B, x);
        
    return (b**N*Q, b**N*R);
    
## Euclidean Algorithms
def Euclidean(PolR, a, b):
    a = PolR(a); b = PolR(b);
    while(b != PolR.zero()):
        (q,r) = PolyDivide(PolR,a,b);
        a = b;
        b = r;
    return a;
    
def ExtendedEuclidean_slow(PolR, a, b):
    a = PolR(a); b = PolR(b);
    a1 = PolR.one(); a2 = PolR.zero(); b1 = PolR.zero(); b2 = PolR.one();
    
    while(b != PolR.zero()):
        (q,r) = PolyDivide(PolR,a,b);
        a = b; b = r;
        r1 = a1-q*b1; r2 = a2-q*b2;
        a1 = b1; a2 = b2; b1 = r1; b2 = r2;
        
    return (a1,a2,a);
    
def HalfExtendedEuclidean(PolR, a, b):
    a = PolR(a); b = PolR(b);
    a1 = PolR.one(); b1 = PolR.zero();
    
    while(b != PolR.zero()):
        (q,r) = PolyDivide(PolR,a,b);
        a = b; b = r;
        r1 = a1-q*b1;
        a1 = b1; b1 = r1;
        
    return (a1,a);
    
def ExtendedEuclidean(PolR, a, b):
    a = PolR(a); b = PolR(b);
    (s,g) = HalfExtendedEuclidean(PolR, a,b);
    (t,r) = PolyDivide(PolR, g-s*a,b);
    
    return (s,t,g);
    
def ExtendedEuclidean_diophantine_slow(PolR, a,b,c):
    a = PolR(a); b = PolR(b); c = PolR(c);
    x = PolR.gens()[-_sage_const_1 ];
    
    (s,t,g) = ExtendedEuclidean(PolR, a,b);
    (q,r) = PolyDivide(PolR, c,g);
    if(r != PolR.zero()):
        raise ValueError("(%s) is not in the ideal generated by (%s) and (%s)" %(c,a,b));
    s = q*s; t = t*q;
    
    if(s != PolR.zero() and (__degree(PolR, s, x) >= __degree(PolR, b, x))):
        (q,r) = PolyDivide(PolR, s,b);
        s = r;
        t = t+q*a;
    return (s,t);
    
def HalfExtendedEuclidean_diophantine(PolR, a,b,c):
    a = PolR(a); b = PolR(b); c = PolR(c);
    x = PolR.gens()[-_sage_const_1 ];
    
    (s,g) = HalfExtendedEuclidean(PolR, a,b);
    (q,r) = PolyDivide(PolR, c,g);
    if(r != PolR.zero()):
        raise ValueError("(%s) is not in the ideal generated by (%s) and (%s)" %(c,a,b));
    s = q*s;
    
    if(s != PolR.zero() and (__degree(PolR, s, x) >= __degree(PolR, b, x))):
        (q,r) = PolyDivide(PolR, s,b);
        s = r;
    return s;
    
def ExtendedEuclidean_diophantine(PolR, a,b,c):
    a = PolR(a); b = PolR(b); c = PolR(c);
    s = HalfExtendedEuclidean_diophantine(PolR, a,b,c);
    (t,r) = PolyDivide(PolR, c-s*a, b);
    return (s,t);
  
## Partial Fractions  
def PartialFraction_simple(PolR, a, d):
    a = PolR(a); d = [PolR(el) for el in d];
    if(len(d) == _sage_const_0 ):
        return [a];
    
    d1 = prod(d); d2 = d1/d[_sage_const_0 ];
    
    (q,r) = PolyDivide(PolR, a,d1);
    if(len(d) == _sage_const_1 ):
        return [q,r];
        
    (a1,t) = ExtendedEuclidean_diophantine(PolR, d2, d[_sage_const_0 ],r);
    aux = PartialFraction_simple(PolR, t,d[_sage_const_1 :])
    
    return [aux[_sage_const_0 ]+q, a1] + aux[_sage_const_1 :];
    
def PartialFraction(PolR, a, d, e = None):
    a = PolR(a); d = [PolR(el) for el in d];
    if(e is None):
        e = [_sage_const_1  for i in range(len(d))];
    else:
        for i in range(len(e)):
            e[i] = int(e[i]);
            if(e[i] < _sage_const_0 ):
                raise ValueError("No negative exponents allowed in the PartialFraction method. The %d-th exponent is negative." %i);
                
    if(len(d) != len(e)):
        raise TypeError("PartialFraction need the same amount of exponents as denominators");
        
    dens = [d[i]**e[i] for i in range(len(d))];
    pf = PartialFraction_simple(PolR, a, dens);
    
    res = [pf[_sage_const_0 ]];
    for i in range(len(e)):
        part_res = [];
        for j in range(e[i],_sage_const_0 ,-_sage_const_1 ):
            (q,aux) = PolyDivide(PolR, pf[i+_sage_const_1 ], d[i]);
            pf[i+_sage_const_1 ] = q;
            part_res += [aux];
        part_res.reverse();
        res[_sage_const_0 ] = res[_sage_const_0 ] + pf[i+_sage_const_1 ];
        res += part_res;
        
    return res;
    
## Primitive part and content of polynomials
def content(PolR, p):
    p = PolR(p);
    x = PolR.gens()[-_sage_const_1 ];
    
    coeffs = __coefficients(PolR, p, x);
    return gcd(coeffs);
    
def pp_only(PolR, p):
    p = PolR(p);
    return p/content(PolR, p);
    
def pp(PolR, p):
    c = content(PolR, p);
    return (c, p/c);
    
## Squarefree factorization
def Squarefree_Musser(PolR, A):
    A = PolR(A);
    x = PolR.gens()[-_sage_const_1 ];
    
    (c,S) = pp(PolR, A);
    
    S_minus = gcd(S, S.derivative(x));
    S_star = PolR(S/S_minus);
    res = []
    while(__degree(PolR, S_minus, x) > _sage_const_0 ):
        Y = gcd(S_star, S_minus);
        res += [PolR(S_star/Y)];
        S_star = Y;
        S_minus = PolR(S_minus/Y);
    res += [S_star];
    
    res[_sage_const_0 ] = res[_sage_const_0 ]*(c*S_minus);
    return res;
    
def Squarefree_Yun(PolR, A):
    A = PolR(A);
    x = PolR.gens()[-_sage_const_1 ];
    
    (c,S) = pp(PolR, A);
    S_prime = S.derivative(x);
    S_minus = gcd(S,S_prime);
    S_star = PolR(S/S_minus);
    Y = PolR(S_prime/S_minus);
    res = [];
    Z = Y - S_star.derivative(x);
    while(Z != _sage_const_0 ):
        res += [gcd(S_star, Z)];
        S_star = PolR(S_star/res[-_sage_const_1 ]);
        Y = PolR(Z/res[-_sage_const_1 ]);
        Z = Y - S_star.derivative(x);
        
    res += [S_star];
    res[_sage_const_0 ] = res[_sage_const_0 ]*c;
    
    return res;
    

