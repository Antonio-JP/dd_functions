
# This file was *autogenerated* from the file ./hermite.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_0 = Integer(0)
from ajpastor.misc.euclidean import *;
from ajpastor.misc.verbose import *;
from ajpastor.misc.matrix import swap_cols as swap;

####################################################################################
###
### Two Stages for Hermite Normal Form
###
####################################################################################
@wverbose
def stage1(A,i):
    parent = A.parent().base();
    sverbose("Initiating the loop...");
    sverbose.start_iteration(i,False,False);
    sverbose.increase_depth();
    for j in range(i):
        (p,q,r) = ExtendedEuclidean(parent, A[j][j],A[j][i]);
        
        sverbose("Computed the EEA: (%s)(%s) + (%s)(%s) = %s" %(p,A[j][j],q,A[j][i],r));
        
        new_rows = [[el for el in row] for row in A];
        p2 = parent(-A[j][i]/r); q2 = parent(A[j][j]/r);
        
        sverbose("Column operation matrix:\n%s" %(Matrix(parent,[[p,p2],[q,q2]])));
        for k in range(A.nrows()):
            new_rows[k][j] = p*A[k][j] + q*A[k][i];
            new_rows[k][i] = p2*A[k][j] + q2*A[k][i];
        coeff = new_rows[j][j].leading_coefficient();
        coeff2 = new_rows[j+_sage_const_1 ][i].leading_coefficient();
        for k in range(A.nrows()):
            new_rows[k][j] = new_rows[k][j]/coeff;
            new_rows[k][i] = new_rows[k][i]/coeff2;
        A = Matrix(parent,new_rows);
        sverbose("New matrix computed:\n%s" %A);
        sverbose.next_iteration();
    sverbose.decrease_depth();
    sverbose("Finished the loop");
    return A;
    
@wverbose
def stage2(Ao, A, i):
    parent = Ao.parent().base();
    m = i+_sage_const_1 ;
    S = Matrix(parent,[[Ao[i][j] for j in range(m)] for i in range(m)]);
    D = Matrix(parent,[([_sage_const_0  for j in range(l)] + [A[l][l]] + [_sage_const_0  for j in range(l+_sage_const_1 ,m)]) for l in range(m)]);
    K = S * BackslashOperator() * D;
    new_rows = [[el for el in row] + [_sage_const_0  for j in range(m,Ao.ncols())] for row in K];
    for j in range(m,Ao.ncols()):
        new_rows += [[_sage_const_0  for k in range(j)] + [_sage_const_1 ] + [_sage_const_0  for k in range(j+_sage_const_1 ,Ao.ncols())]];
    K = Matrix(K.parent().base(), new_rows);
    return Ao*K;
    
####################################################################################
###
### Rearrangement methods
###
####################################################################################
@wverbose_w_data
def index_n_from_m(n,m,subset):
    '''
    Let S(n,m) be the subset of the parts of {1,...,m} with n elements. It is well known that |S(n,m)| = binomial(m,n). Let A(n,m) = {1,2,...,binomial(m,m)}. Then there are bijections between S(n,m) and A(n,m).
    
    Consider f a bijection that orders the elements of S(n,m) in a lexicographic order. This method implements such map.
    
    INPUT:
        - n: size fo the subsets we are considering
        - m: number of elements we can take elements
        - subset: an element of S(n,m).
    '''
    if(not (isinstance(subset,list) or not isinstance(subset,set))):
        raise TypeError("The argument subset must be a set or a list of elements");
        
    subset = list(set(subset)); subset.sort();
    
    if(len(subset) != n):
        raise TypeError("The argument subset must have %d elements, but it has %d" %(n,len(subset)));
    
    for el in subset:
        if((not (isinstance(el,Integer) or type(el)==int)) or (el <= _sage_const_0 ) or (el > m)):
            raise ValueError("The elements of subset must be integers from 1 to %d" %m);
         
    if(n == _sage_const_0 ):
        return _sage_const_0 ;   
    elif(n == _sage_const_1 ):
        return subset[_sage_const_0 ];
            
    return sum(binomial(m-j,n-_sage_const_1 ) for j in range(_sage_const_1 ,subset[_sage_const_0 ])) + index_n_from_m(n-_sage_const_1 ,m-subset[_sage_const_0 ],[subset[i]-subset[_sage_const_0 ] for i in range(_sage_const_1 ,len(subset))]);
    

@wverbose_w_data
def subset_n_from_m(n,m,i):
    '''
    Let S(n,m) be the subset of the parts of {1,...,m} with n elements. It is well known that |S(n,m)| = binomial(m,n). Let A(n,m) = {1,2,...,binomial(m,m)}. Then there are bijections between S(n,m) and A(n,m).
    
    Consider f a bijection that orders the elements of S(n,m) in a lexicographic order (see method index_n_from_m). This method inverts such method.
    
    INPUT:
        - n: size fo the subsets we are considering
        - m: number of elements we can take elements
        - i: index of the subset we want to rebuild.
    '''
    if(n < _sage_const_1  or m < n):
        raise TypeError("Imposible compute this: not valid configuration");
    if(n == _sage_const_1 ):
        sverbose("Base case (n = 1). Returning [%d]" %i);
        return [i];
    bin = binomial(m-_sage_const_1 ,n-_sage_const_1 )
    current_sum = _sage_const_0 ;
    index = _sage_const_1 ;
    while(current_sum + bin < i):
        index += _sage_const_1 ;
        current_sum += bin;
        bin = binomial(m-index,n-_sage_const_1 );
        
    sverbose("Index found: %d" %index);
    
    output = [index] + [el+index for el in subset_n_from_m(n-_sage_const_1 ,m-index,i-current_sum)];
    sverbose("Output: %s" %output);
    
    return [index] + [el+index for el in subset_n_from_m(n-_sage_const_1 ,m-index,i-current_sum)];

@wverbose_w_data
def permutation_from_m(subset,m):
    '''
        Given a subset of {1,2,...,m} on the form [a_1<...<a_n], this method computes a permutation p in S_m such that for all i = 1,...,n
            - p(a_i) = i.
    '''
    perm = [el for el in subset];
    for j in range(_sage_const_1 ,m+_sage_const_1 ):
        if(not j in perm):
            perm += [j];
    return Permutation(perm).inverse();
    
@wverbose_w_data
def get_rearrange_from_minor(nrows,ncols,size,i):
    '''
        Given the size of a matrix, a size of a minor that is not zero and the index of such minor we compute the permutations that move rows and columns in order to have that minor in the left top corner of the matrix.
    '''
    bin = binomial(ncols,size);
    for_rows = subset_n_from_m(size,nrows,ceil(i/bin));
    
    to_cols = i%bin;
    if(to_cols == _sage_const_0 ):
        to_cols = bin;
    for_cols = subset_n_from_m(size,ncols,to_cols);
    
    return (permutation_from_m(for_rows,nrows),permutation_from_m(for_cols,ncols));
    
@wverbose
def get_rearrange(M):
    '''
        Given a matrix M, this method computes the maximal non-zero minor (so, the rank of the matrix) and return the permutations needed to put that minor in the left top corner of the matrix.
    '''
    if(M.nrows() > M.ncols()):
        (o,j) = get_rearrange(M.transpose());
        return ((o[_sage_const_1 ],o[_sage_const_0 ]),j);
    
    done = False;
    j = M.nrows()+_sage_const_1 ;
    while((not done) and (j > _sage_const_1 )):
        j -= _sage_const_1 ;
        i = _sage_const_1 ;
        minors = M.minors(j);
        for el in minors:
            if(el != _sage_const_0 ):
                done = True;
                break;
            i += _sage_const_1 ;
    
    return (get_rearrange_from_minor(M.nrows(),M.ncols(),j,i), j);

@wverbose
def rearrange(M):
    '''
        Method that returns the same matrix M after changing rows and columns in order to have the rank defining minor in the top left corner of the matrix.
    '''
    (orders, size) = get_rearrange(M);
    
    return Matrix(M.parent().base(), [[M[orders[_sage_const_0 ](i+_sage_const_1 )-_sage_const_1 ][orders[_sage_const_1 ](j+_sage_const_1 )-_sage_const_1 ] for j in range(M.ncols())] for i in range(M.nrows())]), size;
    
    
@wverbose
def deep_rearrange(M):
    '''
        Method that returns the same matrix M after changing rows and columns in order to have all the possible principal minors non zero.
    '''
    M,rank = rearrange(M);
    
    nrows = M.nrows(); ncols = M.ncols();
    for i in range(nrows):
        minors = M.minors(i+_sage_const_1 );
        j = i;
        for j in range(i,ncols):
            if(minors[j-i] != _sage_const_0 ):
                break;
        if(j != i):
            M = swap(M,i+_sage_const_1 ,j+_sage_const_1 );
        
    return M;
    
####################################################################################
###
### Hermite Normal Form Method
###
####################################################################################  
@wverbose 
def HNF_square(A, check_argument = True):
    '''
    Method that computes the Hermite Normal Form of a non-singular square matrix.
    
    We can disable the checking for non-singularity changing the argument 'check_argument'.
    '''
    if(A.ncols() != A.nrows()):
        raise TypeError("This method requires a square matrix");
    
    if(check_argument and A.determinant() == _sage_const_0 ):
        raise ValueError("This method requires a non-singular matrix");
        
    sverbose("Matrix before rearrange:\n%s" %A);
    A = deep_rearrange(A);
    sverbose("Matrix after rearrange:\n%s" %A);
        
    current = Matrix(A.parent().base(), [[el for el in row] for row in A]);
    sverbose.start_iteration(A.nrows()-_sage_const_1 , False, False);
    for i in range(_sage_const_1 ,A.nrows()):
        current = stage2(A,stage1(current,i),i);
        sverbose.next_iteration();
    
    return current;
        
@wverbose
def HNF(A):
    if(A.ncols() < A.nrows()):
        sverbose("Case with more rows than columns. Using the transpose case");
        return HNF(A.transpose()).transpose();
        
    parent = A.parent().base();
        
    A,rank = rearrange(A);
    sverbose("Matrix rearrange. The rank computed is %d" %rank);
    new_rows = [[el for el in A[i]] for i in range(rank)];
    for i in range(rank,A.ncols()):
        new_rows += [[kronecker_delta(j,i) for j in range(A.ncols())]];
        
    B = HNF_square(Matrix(parent,new_rows));
    sverbose("Computed the square Hermite Normal Form, we return the first %d rows" %rank);
        
    return Matrix(parent,[[el for el in B[i]] for i in range(rank)] + [[_sage_const_0  for j in range(B.ncols())] for i in range(rank,A.nrows())]);

####################################################################################
###
### Package exports
###
#################################################################################### 
#__all__ = ["HNF"];

