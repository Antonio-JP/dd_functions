
# This file was *autogenerated* from the file ./nullspace_wrapper.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_0 = Integer(0)
from .matrix import swap_rows;
from .matrix import swap_cols;

from .cached_property import derived_property;

from .verbose import *;

from ore_algebra.nullspace import *;

from sage.rings.polynomial.polynomial_ring import is_PolynomialRing as isUniPolynomial;
from sage.rings.polynomial.multi_polynomial_ring import is_MPolynomialRing as isMPolynomial;

class ElementInIdealFound(ValueError):
    # Used for returning an exception with an element that is zero but is not the zero polynomial
    def __init__(self, element):
        self.__element = element;
        print "ElementInIdealFound raised"
    
    def __str__(self):
        return "A zero found: %s" %self.__element;
        
    def element(self):
        return self.__element;

class NullspaceAlgorithm(object):
    ### Initialization method
    def __init__(self, parent, M,  method=None, relations = []):
        '''
            This class represent the application of the Bareiss Algorithm over a matrix with polynomial coefficients.
            This class receives several parameters:
                - `parent`: the polynomial ring where the operations will be done. A fraction field is allowed if the base domain is a polynomial ring.
                - `M`: the matrix we want to treat with the Algorithm
                - `method`: a Boolean function
                
            This algorithm also works in a quotient of the polynomial ring (K[X]/I) and the method provided must be a method to check if some polynomial is in the ideal I.
        '''
        ## Checking the parent parameter
        if(parent.is_field()):
            parent = parent.base();
        if(not (isUniPolynomial(parent) or isMPolynomial(parent))):
            raise TypeError("The parent for this algorithm must be a polynomial ring.\n\t Got: %s" %parent);
        if((not (parent.base() is QQ)) and (not(parent.base() is ZZ))):
            raise TypeError("The parent for these algorithms must be based on rational numbers\n\t Got: %s" %parent);
        self.__parent = PolynomialRing(ZZ,parent.gens());
            
        ## Checking the matrix input
        self.base_matrix = Matrix(parent, M);
        ## If the parent are the Rational numbers we clean denominators
        ## Otherwise, the parent are the Integers, so we can go on.
        if(parent.base() is QQ):
            ## Cleaning rational denominators
            new_rows = [];
            for row in M:
                aux_list = [];
                for el in row:
                    aux_list += [coeff.denominator() for coeff in el.coefficients()];
                den_lcm = lcm(aux_list);
                new_rows += [den_lcm*row];
            M = new_rows;
            self.__matrix = Matrix(self.parent(), M);
        else:
            self.__matrix = self.base_matrix;
        
        ## Storing the checking method
        self.__in_ideal = method;
        
        ## Cached elements
        self.__gb = ideal(self.parent(), relations).groebner_basis();        
                
    ### Getter methods
    def parent(self):
        '''
            Method to have the same interface that the majority of objects of SAGE. Returns the polynomial ring where the matrix have its coefficients.
        '''
        return self.__parent;
        
    #################################################
    ### Linear algebra methods
    #################################################        
    @derived_property
    def rank(self):
        return self.base_matrix.nrows()-self.right_kernel_matrix().ncols();
                
    def relations(self):
        self.right_kernel_matrix();
        return self.__gb;
                
    @cached_method
    def right_kernel_matrix(self):
        solver = self.__decide_solver();
        
        finished = False;
        output = None;
        while(not finished):
            try:
                output = solver(self.__matrix);
                finished = True;
            except ElementInIdealFound as e:
                if(e.element().reduce(self.__gb) == _sage_const_0 ):
                    raise RuntimeError("Same zero detected twice. Probable infinite loop");
                self.__gb = ideal(self.parent(), self.__gb+[e.element()]).groebner_basis();
                self.__matrix = self.__simplify_matrix(self.__matrix);
        ## Putting the output in matrix form
        rows = [[_sage_const_0  for i in range(len(output))] for j in range(self.__matrix.ncols())];
        for i in range(len(output)):
            for j in range(self.__matrix.ncols()):
                rows[j][i] = output[i][j];
        return Matrix(self.parent(), rows);
        
    #################################################
    ### Other cached methods
    #################################################
    @cached_method
    def is_in_ideal(self, p):
        p = self.parent()(p);
        
        try:
            return self.__in_ideal(p) is True;
        except Exception:
            return False;
        
    #################################################
    ### Private methods for the Wrapper 
    #################################################
    @wverbose
    def __pivot(self,M, r, n, c, m, zero):
        # We delegate to the method _pivot of ore_algebra.nullspace
        from ore_algebra.nullspace import _pivot;
        (i,j) = _pivot(M,r,n,c,m,zero);
        sverbose("A pivot found at position (%d,%d): %s" %(i,j,repr(M[i][j])));
        if(self.is_in_ideal(M[i][j])):
            sverbose("The pivot is zero");
            raise ElementInIdealFound(M[i][j]);
        
        return (i,j);
            
    def __decide_solver(self):
        return kronecker(gauss(lambda M,r,n,c,m,zero : self.__pivot(M,r,n,c,m,zero)));
        
    def __have_ideal(self, basis):
        if(len(basis) == _sage_const_1 ):
            return basis[_sage_const_0 ] != _sage_const_0 ;
        return len(basis) > _sage_const_0 ;
        
    def __simplify_matrix(self, M):
        rows = [[el for el in row] for row in M];
        if(self.__have_ideal(self.__gb)):
            rows = [[el.reduce(self.__gb) for el in row] for row in rows];
        
        return Matrix(self.parent(), rows);
        
        

