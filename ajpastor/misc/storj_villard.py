
# This file was *autogenerated* from the file ./storj_villard.sage
from sage.all_cmdline import *   # import sage library

_sage_const_100 = Integer(100); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0)
from .cached_property import derived_property;

from sage.rings.polynomial.polynomial_ring import is_PolynomialRing as isUniPolynomial;

class StorjVillardAlgorithm(object):
    ### Initialization method
    def __init__(self, parent, M):
        '''
            This class represent the application of the Storjohann-Villard algorithm (ISSAC 2005 paper) over a matrix with polynomial coefficients.
            This class receives several parameters:
                - `parent`: the polynomial ring where the operations will be done. A fraction field is allowed if the base domain is a polynomial ring.
                - `M`: the matrix we want to treat with the Algorithm
        '''
        ## Checking the parent parameter
        if(parent.is_field()):
            parent = parent.base();
        if(not (isUniPolynomial(parent))):
            raise TypeError("The parent for this algorithm must be a univariate polynomial ring.\n\t Got: %s" %parent);
        self.__parent = parent;
        
        self.__c_rank = None;
        self.__c_nulls = None;
            
        ## Checking the matrix input
        self.base_matrix = Matrix(self.parent(), M);
        
    ### Getter methods
    def parent(self):
        '''
            Method to have the same interface that the majority of objects of SAGE. Returns the polynomial ring where the matrix have its coefficients.
        '''
        return self.__parent;
        
    #################################################
    ### Linear algebra methods
    ################################################# 
    @derived_property
    def rank(self):
        if(self.__c_rank is None):
            return self.__nullspace()[_sage_const_0 ];
        return self.__c_rank;
                
    @cached_method
    def right_kernel_matrix(self):
        return self.symmetric_problem.left_kernel_matrix();
        
    @cached_method
    def left_kernel_matrix(self):
        if(self.__c_nulls is None):
            return self.__nullspace()[_sage_const_1 ];
        return self.__c_nulls;
        
    #################################################
    ### Other cached methods
    #################################################
    @derived_property
    def symmetric_problem(self):
        return StorjVillardAlgorithm(self.parent(), M.transpose());
    
    #################################################
    ### Private methods for Storjohann-Villard Algorithm 
    #################################################
    def __null_min_vector(self, M, thres):
        '''
            This method receives a matrix M and a degree threshold and computes some vectors in the 
            left null-space of M.
            
            This requires that M has more rows than columns and a maximal rank.
            
            This operation use some random matrices.
        '''
        if(M.nrows() <= M.ncols()):
            raise TypeError("Invalid matrix: more columns than rows");
        n = M.ncols();
        p = M.nrows()-n;
        d = max([max([el.degree() for el in row]) for row in M]);
          
        ## M = QM for a random matrix Q  
        Q = random_matrix(self.parent(), n+p, min=-_sage_const_100 ,max=_sage_const_100 );
        M = Q*M;
        ## M = M(x+x0) for a random x0
        x0 = self.__rand_pol(_sage_const_0 );
        M = Matrix(self.parent(), [[el(x=x+x0) for el in row] for row in M]); 
        
        ## Splitting the matrix into a square matrix and remaining rows
        A = Matrix(self.parent(), [[M[i][j] for j in range(n)] for i in range(n)]);
        B = Matrix(self.parent(), [[M[i][j] for j in range(n)] for i in range(n, n+p)]);
        
        ## Checking rank of M
        if(A.determinant() == _sage_const_0 ):
            raise ValueError("Failure in the algorithm. Probably rank(M) lower than require");
            
        ## Computing some degree bound
        nu = thres+d+int(ceil(n*d/p));
        
        ## Computing a expansion of BA^-1 mod x^nu
        H = raise NotImplementedError("Do not know how to implement this");
        
        ## Compressing the matrix H
        Hp = H*Matrix(self.parent(), [[__rand_pol(d) for i in range(p)] for j in range(n)]);
        t = [d-_sage_const_1  for i in range(p)] + [_sage_const_0  for i in range(p)];
        
        ## Compute a sigma-basis with respect to t for [-Ip Hp^T]^T of order nu
        L = raise NotImplementedError("Do not know how to implement this");
        
        ## Computing kappa = #{rows of L such t-degree is at most thres}
        ordered_rows = {};
        kappa = _sage_const_0 
        for row in L:
            t_degree = max([row[i] - t[i] for i in range(len(t))]);
            if(t_degree <= thres):
                kappa += _sage_const_1 ;
            
            if(ordered_rows.get(t_degree) is None):
                ordered_rows[t_degree] = [];
            ordered_rows[t_degree] = ordered_rows[t_degree] + [row];
        S = [];
        for i in range(thres+_sage_const_1 ):
            S += ordered_rows[i];
        
        ## Computing the partial reconstructions Ni
        N = [el*block_matrix(self.parent(),H,_sage_const_1 ) for i in el];
        N = [Matrix(self.parent(), [[el%((self.parent().gens()[_sage_const_0 ])**(thres+_sage_const_1 )) for el in row] for row in Ni]) for Ni in N];
        N = [Matrix(self.parent(), [[el(x=x-x0) for el in row] for row in Ni]) for Ni in N];
        N = [Ni*Q for Ni in N];
        l = [Ni*M].count(_sage_const_0 );
        
        if(l != kappa):
            raise ValueError("Failure in the algorithm. Error certifiating kappa");
            
        N = Matrix(self.parent(), N);
        
        lc_N = Matrix(self.parent().base(), [[el.leading_coefficient() for el in row] for row in N]);
        if(lc_N.rank() != max(lc_N.nrows(), lc_N.ncols())):
            raise ValueError("Failure in the algorithm. No minimality got");
        
        return kappa, N;
        
    def __nullspace2n(self, M):
        '''
            This method compute some `small` linearly independent polynomial vectors in the nullspace of a matrix M.
            
            Such matrix M must have more rows than columns, but no more than twice.
            
            Moreover, M must have maximal rank.
        '''
        if(M.nrows() <= M.ncols() or M.nrows() > _sage_const_2 *M.ncols()):
            raise TypeError("Invalid matrix: invalid amount of rows with respect to columns");
            
        n = M.ncols();
        q = M.nrows()-n;
        d = max([max([el.degree() for el in row]) for row in M]);
        
        ## M = QM for a random matrix Q  
        Q = random_matrix(self.parent(), n+q, min=-_sage_const_100 ,max=_sage_const_100 );
        M = Q*M;
        
        ## Splitting the matrix into a square matrix and remaining rows
        A = Matrix(self.parent(), [[M[i][j](x=self.__rand_pol(_sage_const_0 )) for j in range(n)] for i in range(n)]);
        
        if(A.determinant() == _sage_const_0 ):
            raise ValueError("Failure in the algorithm. Non singular upper part of matrix");
            
        I = set();
        p = q;
        
        res = [];
        
        while(len(I) < q):
            ## Getting indices left
            index_to_check = set([n+i for i in range(_sage_const_1 ,q+_sage_const_1 )])-I;
            
            ## Computing a degree bound
            delta = _sage_const_2 *n*d/p;
            
            ## Building a matrix C
            rows = [[_sage_const_0  for j in range(n+q)] for i in range(n+p)];
            for i in range(n):
                rows[i][i] = _sage_const_1 ;
            for j in range(p):
                rows[n+j][index_to_check[j]] = _sage_const_1 ;
            C = Matrix(self.parent().base(), rows);
            
            ## Using C and M to use the null_min_vector method
            M1 = C*M;
            kappa, D = self.__null_min_vector(M1, delta);
            N = Matrix(self.parent(),[Di*C for Di in D]);
            
            ## Getting new indices
            J = raise NotImplementedError("Do not know how to implement this");
            
            ## Updating loop variables
            I = I + set(J);
            p = p - kappa;
            
            ## Nullspace update
            res = block_matrix(self.parent(), res.transpose(), N.transpose()).transpose();
            
        return res*Q;
        
    def __nullspace(self):
        '''
        This method privately compute the left kernel of the matrix and its rank and stores the result in cached variables of the structure.
        
        This method returns both the rank and the minimal basis.
        '''
        m = self.base_matrix.nrows();
        n = self.base_matrix.ncols();
        d = max([max([el.degree() for el in row]) for row in M]);
        
        ## Computing a guess r0 for rank
        r0 = raise NotImplementedError("Do not know how to implement this");
        M1 = raise NotImplementedError("Do not know how to implement this");
        
        ## If the guess is too big, we can return an empty nullspace
        if(m == r0):
            self.__c_rank = m;
            self.__c_nulls = [];
            
            return self.__c_rank, self.__c_nulls;
            
        ## Randomly ensure that the top r0xr0 submatrix of M1 is non-singular
        raise NotImplementedError("Do not know how to implement this");
        
        s = int(ceil((m-_sage_const_2 *r0)/r0));
        
        ## Getting the 
        N = [];
        for k in range(s):
            N += [row for row in self.__null_min_vector(raise NotImplementedError("Do not know how to implement this"), d)[_sage_const_1 ]];
        N += [row for row in self.__nullspace2n(raise NotImplementedError("Do not know how to implement this"))];
        
        N = Matrix(self.parent(), N);
        if(N*M != _sage_const_0 ):
            raise ValueError("Failure in the algorithm. No kernel computed");
            
        self.__c_rank = r0;
        self.__c_nulls = N;
        
        return self.__c_rank, self.__c_nulls;
        
        
    def __rand_pol(self, degree):
        return self.parent()([randint(-_sage_const_100 ,_sage_const_100 ) for i in range(randint(_sage_const_0 ,degree)+_sage_const_1 )]);

