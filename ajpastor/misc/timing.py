
# This file was *autogenerated* from the file ./timing.sage
from sage.all_cmdline import *   # import sage library

_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_60 = Integer(60); _sage_const_24 = Integer(24)

    
##########################################
###
### TIME OPERATIONS
###
##########################################
from timeit import default_timer as timer;

__GLOBAL_TIMER = None;
__GENERAL_TIMER = None;
def start_timer(reset = False):
    global __GLOBAL_TIMER;
    global __GENERAL_TIMER;
    
    if(reset):
        __GENERAL_TIMER = timer();
    
    __GLOBAL_TIMER = timer();
    
def finish_timer(text = "an action"):    
    global __GLOBAL_TIMER;
    t = timer() - __GLOBAL_TIMER;
    __print_timer(t, "Perfomed %s: it took" %(text));
    
def get_general_timing():    
    global __GENERAL_TIMER;
    t = timer() - __GENERAL_TIMER;
    __print_timer(t, "General timing:");
    
def __print_timer(T, text):
    END = "secs.";
    if(T > _sage_const_60 ):
        END = "mins.";
        T = float(T/_sage_const_60 );
        
        if(T > _sage_const_60 ):
            END = "h.";
            T = float(T/_sage_const_60 );
            
            if(T > _sage_const_24 ):
                END = "days"
                T = float(T/_sage_const_24 );
    print "%s %s %s" %(text, T, END);

##########################################
###
### COMPARISON BETWEEN METHODS
###
##########################################  
def __compare_methods(arguments, *args):
    if(len(args) == _sage_const_1  and (type(args[_sage_const_0 ]) == list)):
        args = args[_sage_const_0 ];
        
    res = [arguments];
    for method in args:
        try:
            init = timer();
            method(*arguments);
            time = timer()-init;
            res += [time];
        except Exception as e:
            print e
            res += [-_sage_const_1 ];
    return res;
    
def __compare_for_entries(entries, *args):
    if(len(args) == _sage_const_0  and type(args[_sage_const_0 ]) == list):
        args = args[_sage_const_0 ];
    try:
        res = [["Entry\Alg"] + [el.__name__ for el in args]];
        for arguments in entries:
            res += [__compare_methods(arguments, *args)];
            
        return res;
    except AttributeError:
        raise ValueError("The args must be a list of methods");
             
def __compute_global_stats(results):
    try:
        res = [["Stat\Alg"] + [el for el in results[_sage_const_0 ][_sage_const_1 :]]];
        reverse = [[results[i][j] for i in range(len(results))] for j in range(len(results[_sage_const_0 ]))];
        stats = [];
        for i in range(_sage_const_1 , len(results[_sage_const_0 ])):
            stats += [__compute_stats(reverse[i][_sage_const_1 :])];
            
        res += [["Mean"] + [stats[j][_sage_const_0 ] for j in range(len(stats))]];
        res += [["Min"] + [stats[j][_sage_const_1 ] for j in range(len(stats))]];
        res += [["Max"] + [stats[j][_sage_const_2 ] for j in range(len(stats))]];
        res += [["N. Err"] + [stats[j][_sage_const_3 ] for j in range(len(stats))]];
        
        return res;
    except (TypeError, IndexError):
        raise TypeError("The input for compute stats must be a list of lists with at least one row");
        
def __compute_stats(results):
    cMin = float('inf');
    cMax = float('-inf');
    cSum = _sage_const_0 ;
    
    for el in results:
        cSum += el;
        cMin = min(cMin, el);
        cMax = max(cMax, el);
    
    return [cSum/len(results), cMin, cMax, results.count(-_sage_const_1 )];
    
def full_comparison(entries, *args):
    if(len(args) == _sage_const_1  and (type(args[_sage_const_0 ]) == list)):
        args = args[_sage_const_0 ];
    
    return __compute_global_stats(__compare_for_entries(entries, *args));

