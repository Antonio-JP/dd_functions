
# This file was *autogenerated* from the file ./verbose.sage
from sage.all_cmdline import *   # import sage library

_sage_const_100 = Integer(100); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0)
####################################################################
###
### verbose.sage
###
### Code for perform an easy conditional printing.
###
### Version 0.0 (12-07-2017)
###
### Version 1.0 (06-10-2017)
###     - Changed the main system of verbose
###     - Private class __verbose_session created
###     - Visible instance sverbose created
###     - To print with the sverbose session, use the call method ``sverbose(text)``
###     - To change the configuration of the sverbose, call the public methods of the class
###     - Added a decorator to easily set up a function to verbose
###
####################################################################

import sys;
from functools import wraps;

class __verbose_session(object):
    def __init__(self):
        self.__time = True;
        self.__current_depth = _sage_const_0 ;
        self.__level = _sage_const_1 ;
        self.__default_beg = "";
        self.__begs = ["** ","## ","-- ","%% ","&& ","@@ "];
        self.__end = "\n";
        self.__deep_wrapper = _sage_const_0 ;
        
        self.__n_iterations = _sage_const_0 ;
        self.__perc = False;
        self.__inline = True;
        self.__current_iteration = _sage_const_0 ;
        
    ## Basic call method
    def __call__(self,string, end=None):
        if(self.__level+self.__current_depth <= get_verbose()):
            if(self.__time):
                from datetime import datetime as time;
                print "|",str(time.now()), "|",
            for i in range(self.__current_depth):
                print "\t",
            if(self.__current_depth > _sage_const_0 ):
                print self.__begs[(self.__current_depth-_sage_const_1 )%len(self.__begs)],
            else:
                print self.__default_beg,
            
            print string,
            if(not(end is None)):
                print end,
            else:
                print self.__end,
                
            sys.stdout.flush();
        return;
        
    ## Changing level of verbose for the session
    def get_level(self):
        return self.__level;
        
    def set_level(self, level):
        self.__level = level;
        
    ## Changing the time printing
    def set_time(self, time):
        self.__time = time;
        
    def get_time(self, time):
        return self.__time;
            
    ## Changing depth methods
    def reset_depth(self):
        self.__current_depth = _sage_const_0 ;
    
    def change_depth(self,amount):
        self.__current_depth = max(_sage_const_0 , self.__current_depth+amount);
        
    def increase_depth(self,amount = _sage_const_1 ):
        if(amount < _sage_const_0 ):
            raise ValueError("To increase the tab depth it is needed a positive number, not %d" %amount);
        self.change_depth(amount);
        
    def decrease_depth(self,amount = _sage_const_1 ):
        if(amount < _sage_const_0 ):
            raise ValueError("To decrease the tab depth it is needed a positive number, not %d" %amount);
        self.change_depth(-amount);
        
    ## Changing the wrapper behavior
    def get_deep_wrapper(self):
        return self.__deep_wrapper;
        
    def set_deep_wrapper(self, new_deep):
        self.__deep_wrapper = new_deep;
        
    ## Changing default beginning
    def get_default_beginning(self):
        return self.__default_beginning;
        
    def set_default_beginning(self, beg):
        self.__default_beginning = beg;
        
    ## Iteration helping system variables
    def get_n_iterations(self):
        return self.__n_iterations;
    def set_n_iterations(self, n_iterations):
        self.__n_iterations = n_iterations;
        
    def get_perc(self):
        return self.__perc;
    def set_perc(self, perc):
        self.__perc = perc;
        
    def get_inline(self):
        return self.__inline;
    def set_inline(self, inline):
        self.__inline = inline;
        
    def get_current_iteration(self):
        return self.__current_iteration;
    def set_current_iteration(self, current_iteration):
        self.__current_iteration = current_iteration;
        
    def get_iteration_state(self):
        return {'n': self.__n_iterations, 'perc' : self.__perc, 'inline' : self.__inline, 'current' : self.__current_iteration};
        
    def set_iteration_state(self, state):
        try:
            self.__n_iterations = state['n'];
            self.__perc = state['perc'];
            self.__inline = state['inline'];
            self.__current_iteration = state['current'];
        except KeyError:
            pass;
            
    ## Iteration helping system
    def start_iteration(self,iterations, percentage = False, in_line = True):
        self.__n_iterations = iterations;
        self.__perc = percentage;
        self.__inline = in_line;
        self.__current_iteration = _sage_const_1 ;
        
    def next_iteration(self):
        msg = "Performed %d-th iteration " %self.__current_iteration;
         
        if(self.__perc and self.__n_iterations > _sage_const_0 ):
            msg += "(%.2f %%)" %(self.__current_iteration*_sage_const_100 /self.__n_iterations);
        else:
            msg += "(%d/%d)" %(self.__current_iteration, self.__n_iterations);
            
        if(self.__inline and self.__current_iteration < self.__n_iterations):
            end = "\r";
        else:
            end = None;
            
        self(msg, end);
        self.__current_iteration += _sage_const_1 ;
    
## Conditional definition of the verbose variables
sverbose = __verbose_session();

class VerboseError(RuntimeError):
    def __init__(self):
        pass;

#@wraps
def wverbose(func):
    ## Creating the wrapped function
    def wrapped_function(*args, **kwds):
        try:
            sverbose.increase_depth(sverbose.get_deep_wrapper());
            sverbose("Calling method %s" %(func.__name__));
            state = sverbose.get_iteration_state();
            sverbose.increase_depth();
        except Exception:
            raise VerboseError();
            
        e = None;
        try:
            output = func(*args,**kwds);
        except Exception as e:
            pass;
        except KeyboardInterrupt as e:
            pass;
        sverbose.decrease_depth();
        sverbose.set_iteration_state(state);
        
        if(not e is None):
            sverbose("Exception raised in method %s" %(func.__name__));
            sverbose.decrease_depth(sverbose.get_deep_wrapper());
            raise e;
        else:
            sverbose("Finished method %s" %(func.__name__));
            sverbose.decrease_depth(sverbose.get_deep_wrapper());
            return output;
        
    ## Setting up the other attributes for the wrapped function
    wrapped_function.__doc__ = getattr(func, '__doc__');
    
    return wrapped_function;
    
#@wraps
def wverbose_w_data(func):
    ## Creating the wrapped function
    def wrapped_function(*args, **kwds):
        try:
            sverbose.increase_depth(sverbose.get_deep_wrapper());
            sverbose("Calling method %s" %(func.__name__));
            sverbose("Arguments:");
            if(len(args) > _sage_const_0 ):
                sverbose("%s" %(str(args)));
            if(len(kwds)> _sage_const_0 ):
                sverbose("%s" %(str(kwds)));
            state = sverbose.get_iteration_state();
            sverbose.increase_depth();
        except Exception:
            raise VerboseError();
        
        e = None;
        try:
            output = func(*args,**kwds);
        except Exception as e:
            pass;
        except KeyboardInterrupt as e:
            pass;
        sverbose.decrease_depth();
        sverbose.set_iteration_state(state);
        
        if(not e is None):
            sverbose("Exception raised in method %s" %(func.__name__));
            sverbose.decrease_depth(sverbose.get_deep_wrapper());
            raise e;
        else:
            sverbose("Finished method %s" %(func.__name__));
            sverbose("Output: %s" %(str(output)));
            sverbose.decrease_depth(sverbose.get_deep_wrapper());
            return output;
        
    ## Setting up the other attributes for the wrapped function
    wrapped_function.__doc__ = getattr(func, '__doc__');
    
    return wrapped_function;

__all__ = ["sverbose", "wverbose", "wverbose_w_data"];

__VERBOSE_LEVEL = None;
try:
    set_verbose(get_verbose());
except Exception:
    __VERBOSE_LEVEL = _sage_const_0 ;
    def set_verbose(level):
        global __VERBOSE_LEVEL;
        __VERBOSE_LEVEL = max(_sage_const_0 , level);
        if(__VERBOSE_LEVEL >= _sage_const_1 ):
            print "-- Changed verbose level to %d" %(__VERBOSE_LEVEL);
    
    def get_verbose():
        global __VERBOSE_LEVEL;
        return __VERBOSE_LEVEL;
        
    __all__ += ["set_verbose", "get_verbose"];
        

## Getters and setters of the verbose level
#def set_verbose(level):
#    global __VERBOSE_LEVEL;
#    
#    __VERBOSE_LEVEL = max(0, level);
#    verbose("-- Changed verbose level to %d" %(__VERBOSE_LEVEL), 1);
#    
#def get_verbose():
#    global __VERBOSE_LEVEL;
#    return __VERBOSE_LEVEL;
    
## Main printing function
#def verbose(text, level = 0, end = '\n', depth = 0, beg = '', time = False):
#    global __VERBOSE_LEVEL;
#    
#    if(level <= __VERBOSE_LEVEL):
#        if(time):
#            from datetime import datetime as time;
#            print str(time.now()), " --",
#        for i in range(depth):
#            print "\t",
#        if(len(beg) > 0):
#            print beg, " ",
#        print text,
#        print end,
#        sys.stdout.flush();
        
## Other useful methods
#__sv_active = False;
#__sv_time = False;
#__sv_current_depth = 0;
#__sv_current_level = 0;
#__sv_beg = "";
#__sv_end = "\n";

## Making smart verbose
#def sverbose(text, end=None):
#    global __sv_active;
#    global __sv_current_depth;
#    global __sv_current_level;
#    global __sv_beg;
#    global __sv_time;
#    global __sv_end;
#    if(end is None):
#        tend = __sv_end;
#    else:
#        tend = end;
#        
#    if(__sv_active):
#        verbose(text, __sv_current_level, end=tend, depth=__sv_current_depth, beg=__sv_beg, time=__sv_time);

## Starting and finishing sessions
#def start_smart_verbose(level, time=True):
#    global __sv_active;
#    global __sv_current_depth;
#    global __sv_current_level;
#    global __sv_time;
#    
#    if(__sv_active):
#        verbose("A smart verbose session was already initiated. Reseting session...", 1, beg = "--");
    
#    __sv_active = True;
#    __sv_time = time;
#    __sv_current_depth = 0;
#    __sv_current_level = level;
#    
#def end_smart_verbose():
#    global __sv_active;
#    
#    __sv_active = False;
    
## Changing depth in smart session
#def change_depth(amount):
#    global __sv_active;
#    global __sv_current_depth;
#    
#    if(__sv_active):
#        __sv_current_depth = max(0, __sv_current_depth+amount);
#
#def increase_depth(amount = 1):
#    if(amount <= 0):
#        raise ValueError("To increase the tab depth it is needed a positive number, not %d" %amount);
#    change_depth(amount);
#    
#def decrease_depth(amount = 1):
#    if(amount <= 0):
#        raise ValueError("To decrease the tab depth it is needed a positive number, not %d" %amount);
#    change_depth(-amount);
#    
#def change_beginning(beg = ""):
#    global __sv_beg;
#    __sv_beg = beg;
    
## Printing iterations in smart session
#__sv_iteration = False;
#__sv_n_iterations = 0;
#__sv_perc = False;
#__sv_inline = True;
#__sv_current_iteration = 0;
#def start_iteration(iterations, percentage = False, in_line = True):
#    global __sv_iteration;
#    global __sv_n_iterations;
#    global __sv_perc;
#    global __sv_inline;
#    global __sv_current_iteration;
#    
#    __sv_iteration = True;
#    __sv_n_iterations = iterations;
#    __sv_perc = percentage;
#    __sv_inline = in_line;
#    __sv_current_iteration = 1;
#    
#def next_iteration():
#    global __sv_iteration;
#    global __sv_n_iterations;
#    global __sv_perc;
#    global __sv_inline;
#    global __sv_current_iteration;
#    
#    if(__sv_iteration):
#        msg = "Performed %d-th iteration " %__sv_current_iteration;
#        
#        if(__sv_perc and __sv_n_iterations > 0):
#            msg += "(%.2f %%)" %(__sv_current_iteration*100/__sv_n_iterations);
#        else:
#            msg += "(%d/%d)" %(__sv_current_iteration, __sv_n_iterations);
#            
#        if(__sv_inline):
#            end = "\r";
#        else:
#            end = None;
#            
#        sverbose(msg, end);
#        __sv_current_iteration += 1;
#        
#def end_iteration():
#    global __sv_iteration;
#    global __sv_inline;
#    global __sv_current_level;
#    global __VERBOSE_LEVEL;
#    
#    if(__sv_iteration):
#        __sv_iteration = False;
#        if(__sv_inline and __sv_current_level <= __VERBOSE_LEVEL):
#            print "";
   

